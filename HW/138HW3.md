a) Utility Class
ตัวอย่างคลาส: System.Math 

บทวิเคราะห์เหตุผล:
Static Members Only: สมาชิกทั้งหมดภายในคลาสนี้ (เช่น Math.Max, Math.Abs, Math.Sin, หรือค่าคงที่ Math.PI) เป็น static ทั้งหมด

Cannot be Instantiated: เราไม่สามารถสร้าง Object จากคลาสนี้ได้ (ไม่สามารถเขียน new Math()) เนื่องจากมันถูกออกแบบมาให้เป็นเพียงที่รวบรวมฟังก์ชันการคำนวณ (Pure Functions) เท่านั้น ไม่มีการเก็บสถานะ (State) ของวัตถุ

Stateless: การเรียกใช้งานเมธอดใน Math ไม่ขึ้นอยู่กับข้อมูลที่เก็บไว้ก่อนหน้า ผลลัพธ์ขึ้นอยู่กับพารามิเตอร์ที่ส่งเข้าไปเท่านั้น ซึ่งเป็นลักษณะสำคัญของ Utility Class

b) Mutable Class
ตัวอย่างคลาส: System.Text.StringBuilder 

บทวิเคราะห์เหตุผล:
State Modification: คลาสนี้ถูกออกแบบมาเพื่อจัดการข้อความที่ "แก้ไขได้" โดยเฉพาะ

In-place Operation: เมื่อเราเรียกใช้เมธอดเช่น .Append(), .Remove(), หรือ .Replace() ตัวโปรแกรมจะเข้าไปแก้ไขข้อมูลในหน่วยความจำของ Object เดิม โดยตรง ไม่ได้สร้าง Object ใหม่

Properties Change: ค่า Properties ต่างๆ เช่น Length หรือ Capacity สามารถเปลี่ยนแปลงได้ตลอดเวลาหลังจากที่ Object ถูกสร้างขึ้นแล้วตามการใช้งาน

c) Immutable Class
ตัวอย่างคลาส: System.String

บทวิเคราะห์เหตุผล:
Read-Only State: เมื่อสร้าง String ขึ้นมาหนึ่งตัว (เช่น string s = "Hello";) ข้อมูลชุดนั้นจะถูกบันทึกในหน่วยความจำและไม่สามารถแก้ไขได้อีก

Modification creates new Instance: หากเราพยายามแก้ไข เช่นเรียกใช้ .ToUpper(), .Substring(), หรือนำมาต่อคำ (+) .NET จะไม่ได้แก้ที่ตัวเดิม แต่จะ สร้าง Object ใหม่ (New Instance) ขึ้นมาแทนที่ แล้วส่งค่ากลับมา ส่วน Object เดิมยังคงเหมือนเดิมทุกประการ

Thread Safety: เนื่องจากสถานะภายในไม่สามารถเปลี่ยนได้ ทำให้ System.String มีความปลอดภัยสูงเมื่อถูกใช้งานพร้อมกันหลาย Thread (Thread-safe) โดยไม่ต้องกังวลว่าค่าจะเพี้ยนระหว่างทาง
